#!/usr/bin/env bash
set -uo pipefail

# Claude Code Reactive Failover Wrapper
# Wraps 'claude' command. Detects actual API failures, switches to AWS Bedrock.
# Self-heals: probes Anthropic after successful Bedrock sessions.
#
# State machine:
#   0        → Anthropic, healthy
#   1, 2     → Anthropic, accumulating failures
#   failover → Bedrock active
#   recovery → Next session probes Anthropic
#
# Install: bash function in .bashrc → claude() { ~/repos/imladris/ai-failover/claude-failover "$@"; }

readonly STATE_FILE="${HOME}/.claude/ai-failover-state"
readonly ENV_FILE="${HOME}/.claude/ai-provider.env"
readonly LOG_DIR="${HOME}/.claude/logs"
readonly LOG_FILE="${LOG_DIR}/ai-failover.log"
readonly FAILURE_THRESHOLD=3
readonly FAST_FAILURE_WINDOW=30  # seconds — only failures within this window count as API issues

mkdir -p "${LOG_DIR}" "$(dirname "${STATE_FILE}")"

log() {
    local level="$1"; shift
    echo "$(date -u '+%Y-%m-%dT%H:%M:%SZ') [${level}] $*" >> "${LOG_FILE}"
}

get_state() { cat "${STATE_FILE}" 2>/dev/null || echo "0"; }
set_state() { echo "$1" > "${STATE_FILE}"; }

write_anthropic_env() {
    cat > "${ENV_FILE}" <<'ENVEOF'
# Auto-generated by claude-failover — do not edit manually
# Provider: Anthropic (direct)
ENVEOF
}

write_bedrock_env() {
    cat > "${ENV_FILE}" <<'ENVEOF'
# Auto-generated by claude-failover — do not edit manually
# Provider: AWS Bedrock (failover active)
export CLAUDE_CODE_USE_BEDROCK=1
export AWS_REGION=us-east-1
ENVEOF
}

is_in_failover() {
    [[ -f "${ENV_FILE}" ]] && grep -q 'CLAUDE_CODE_USE_BEDROCK=1' "${ENV_FILE}" 2>/dev/null
}

# Detect API/connection failures from Claude Code stderr.
# Only counts fast failures (<30s) with connection-related error patterns.
# Long sessions that exit non-zero are user-initiated (Ctrl-C, /exit, etc).
is_api_failure() {
    local stderr_file="$1" duration="$2"
    [[ ${duration} -ge ${FAST_FAILURE_WINDOW} ]] && return 1
    [[ ! -s "${stderr_file}" ]] && return 1
    grep -qiE '(connect|timeout|refused|ECONNREFUSED|ETIMEDOUT|ENOTFOUND|network|fetch.?failed|API.?error|50[023]|529|overloaded|unreachable|socket hang up)' "${stderr_file}" 2>/dev/null
}

retry_on_bedrock() {
    # Guard: max one retry per invocation to prevent infinite loop
    if [[ "${FAILOVER_RETRY:-0}" -ge 1 ]]; then
        log "ERROR" "Bedrock retry also failed — both providers may be down"
        return 1
    fi
    log "INFO" "Retrying session on Bedrock"
    source "${ENV_FILE}"
    export FAILOVER_RETRY=1
    exec "$0" "$@"
}

main() {
    local state
    state=$(get_state)

    # ── Pre-session: configure provider ──
    [[ -f "${ENV_FILE}" ]] && source "${ENV_FILE}"

    local is_probe=false
    if [[ "${state}" == "recovery" ]]; then
        log "INFO" "Recovery probe — trying Anthropic"
        unset CLAUDE_CODE_USE_BEDROCK 2>/dev/null || true
        is_probe=true
    fi

    # ── Run Claude Code ──
    local tmp_err start_time
    tmp_err=$(mktemp)
    start_time=$(date +%s)

    # Capture stderr for failure analysis while still displaying to user
    command claude "$@" 2> >(tee "${tmp_err}" >&2)
    local exit_code=$?

    sleep 0.2  # let tee flush

    local duration=$(( $(date +%s) - start_time ))

    # ── Post-session: update failover state ──

    if [[ ${exit_code} -eq 0 ]]; then
        # ✓ Session succeeded
        if [[ "${is_probe}" == "true" ]]; then
            log "INFO" "Anthropic recovered — switching back from Bedrock"
            write_anthropic_env
            set_state "0"
        elif [[ "${state}" == "failover" ]]; then
            log "INFO" "Bedrock session succeeded — will probe Anthropic next session"
            set_state "recovery"
        else
            [[ "${state}" != "0" ]] && log "INFO" "Session OK — resetting failure count (was ${state})"
            set_state "0"
        fi

    elif is_api_failure "${tmp_err}" "${duration}"; then
        # ✗ API failure detected
        if [[ "${is_probe}" == "true" ]]; then
            log "WARN" "Recovery probe failed — staying on Bedrock"
            write_bedrock_env
            set_state "failover"
            rm -f "${tmp_err}"
            retry_on_bedrock "$@"
        elif [[ "${state}" == "failover" ]]; then
            log "ERROR" "Bedrock also failing (exit=${exit_code}, ${duration}s)"
        else
            local count="${state}"
            [[ ! "${count}" =~ ^[0-9]+$ ]] && count=0
            count=$((count + 1))

            if [[ ${count} -ge ${FAILURE_THRESHOLD} ]]; then
                log "WARN" "${count} consecutive API failures — activating Bedrock failover"
                write_bedrock_env
                set_state "failover"
                rm -f "${tmp_err}"
                retry_on_bedrock "$@"
            else
                log "WARN" "API failure — ${count}/${FAILURE_THRESHOLD}"
                set_state "${count}"
            fi
        fi

    else
        # Non-API exit (Ctrl-C, /exit, crash, etc.) — don't touch failover state
        log "DEBUG" "Non-API exit (code=${exit_code}, ${duration}s) — state unchanged"
    fi

    rm -f "${tmp_err}"
    return ${exit_code}
}

main "$@"
